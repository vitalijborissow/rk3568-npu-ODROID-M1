# Open Questions & Answers

---

## Q1: Can we get 1.2 GHz, 100 MHz, replace all 4 clocks, or get rounder MHz numbers?

### RK3568 NPU Clock Architecture

The NPU has **two independent clock paths**:

1. **CRU path** (Clock & Reset Unit — hardware dividers):
   - `clk_npu_src` has two possible parents: **npll** (1200 MHz) and **gpll** (1200 MHz)
   - `clk_npu_src` is a COMPOSITE clock with a 4-bit integer divider (÷1…÷16)
   - From `clk_npu_src` → `clk_npu_pre_ndft` → `clk_npu` → branches to `aclk_npu_pre`, `hclk_npu_pre`, `pclk_npu_pre`
   - All 3 bus clocks (`aclk`, `hclk`, `pclk`) are derived from `clk_npu` via fixed dividers
   - **Max reachable via CRU**: 1200 MHz ÷ 2 = **600 MHz** (divider has no `CLK_SET_RATE_PARENT`, so it cannot retune npll)
   - CRU gives non-round values because 1200 MHz ÷ N: 1200, 600, 400, 300, 240, 200, ~171, 150, ~133, 120, ~109, 100, ~92, …

2. **SCMI path** (ARM System Control & Management Interface — firmware-controlled):
   - `clk_scmi_npu` — controlled by ARM Trusted Firmware via SCMI protocol
   - Supported rates: 198, 297, 396, 594, 600, 700, 800, 900, 1000 MHz
   - Above 1000 MHz: **1100 MHz silently maps to 594 MHz** (firmware gap), **1188 MHz crashes the board**
   - Safe max: **1000 MHz**

3. **PVTPLL** (Process-Voltage-Temperature PLL) — deep dive:

   **What it is:**
   PVTPLL is a ring-oscillator-based clock source built into the RK3568 silicon. Unlike a
   traditional PLL (which locks to a reference crystal), a PVTPLL generates a clock signal by
   routing a pulse through a chain of logic gates ("ring") — the output frequency is determined
   by the **ring length** (number of gates) and the **ring selector** (which ring topology to use).

   The key insight: the ring oscillator's frequency is **inherently sensitive to Process (silicon
   quality), Voltage, and Temperature**. A "fast" chip at low temperature oscillates faster than a
   "slow" chip at high temperature — for the exact same ring configuration. This is the feature,
   not a bug: PVTPLL automatically **adapts to the specific chip's silicon characteristics**.

   **Hardware in the RK3568:**
   The clock tree in `clk-rk3568.c` defines:
   ```
   PNAME(clk_npu_p) = { "clk_npu_pre_ndft", "npu_pvtpll_out" };
   MUX(CLK_NPU, "clk_npu", clk_npu_p, CLK_SET_RATE_PARENT, CLKSEL_CON(7), bit15, ...);
   GATE(CLK_NPU_PVTPLL, "clk_npu_pvtpll", "clk_npu_pre_ndft", CLK_IGNORE_UNUSED, ...);
   ```
   This means `clk_npu` is a 2:1 mux (bit 15 of CLKSEL_CON7):
   - **bit15=0**: `clk_npu_pre_ndft` → CRU path (current, max 600 MHz)
   - **bit15=1**: `npu_pvtpll_out` → PVTPLL ring oscillator output

   The hardware registers live at **GRF_NPU base 0xFDC2_0000**. The PVTM measurement unit
   (different from PVTPLL!) lives at **0xFDE9_0000** with 7 ring selectors.

   **Live clock tree confirms the mux exists but PVTPLL is unused:**
   ```
   clk_npu_pre_ndft     0  1  0  200000000   (current parent of clk_npu)
      clk_npu_pvtpll     0  0  0  200000000   (gate exists, enable_count=0)
      clk_npu            0  3  0  200000000   (mux output → npu@fde40000)
   ```

   **How Rockchip BSP 5.10 used PVTM (predecessor system):**
   The Hardkernel BSP kernel (5.10) uses a **PVTM** (Process Voltage Temperature Monitor) system,
   not the newer PVTPLL driver. This is a two-step process:

   1. **PVTM measurement** (`rockchip_pvtm.c`): At boot, the kernel measures the chip's
      ring oscillator frequency at a known voltage/temperature/clock:
      ```dts
      /* From rk3568.dtsi (Hardkernel BSP) */
      npu-opp-table {
          rockchip,pvtm-voltage-sel = <
              0        84000   0    /* PVTM < 84000 → voltage level 0 */
              84001    87000   1    /* PVTM 84001-87000 → level 1 */
              87001    91000   2    /* PVTM 87001-91000 → level 2 */
              91001    100000  3    /* PVTM > 91001 → level 3 */
          >;
          rockchip,pvtm-freq = <408000>;      /* measure at 408 MHz */
          rockchip,pvtm-volt = <900000>;      /* measure at 900 mV */
          rockchip,pvtm-ch = <0 5>;           /* NPU PVTM channel 0, sub-channel 5 */
          rockchip,pvtm-sample-time = <1000>; /* 1000 µs sample window */
          rockchip,pvtm-number = <10>;        /* average 10 measurements */
          rockchip,pvtm-ref-temp = <40>;      /* reference temperature 40°C */
          rockchip,pvtm-temp-prop = <26 26>;  /* temperature compensation */
      };
      ```

   2. **Voltage selection** (`rockchip_opp_select.c`): Based on the PVTM measurement, each
      OPP entry selects the appropriate voltage column:
      ```dts
      opp-800000000 {
          opp-microvolt = <925000 925000 1000000>;     /* default */
          opp-microvolt-L0 = <925000 925000 1000000>;  /* slow silicon */
          opp-microvolt-L1 = <900000 900000 1000000>;  /* medium */
          opp-microvolt-L2 = <875000 875000 1000000>;  /* fast silicon */
          opp-microvolt-L3 = <875000 875000 1000000>;  /* fastest */
      };
      ```
      A "fast" chip (high PVTM count) gets lower voltage → **less power, less heat**.
      A "slow" chip (low PVTM count) gets higher voltage → **guaranteed stability**.

   **The newer PVTPLL driver (`clk-pvtpll.c` in Rockchip 6.6 kernel):**
   This is an evolution of the PVTM system used on **newer SoCs** (RV1103B, RV1126B, RK3506).
   It goes one step further: instead of just measuring and selecting voltage, it uses the ring
   oscillator **directly as the clock source**. The driver:
   - Registers as a `clk_hw` clock provider (output name: "pvtpll")
   - Has a frequency→ring_length lookup table per SoC:
     ```c
     /* From rv1103b_npu_pvtpll_table[] */
     ROCKCHIP_PVTPLL_VOLT_SEL(1000000000, 1, 12, 7),  /* 1 GHz, ring_sel=1, length=12 */
     ROCKCHIP_PVTPLL_VOLT_SEL(900000000,  1, 12, 6),   /* 900 MHz */
     ROCKCHIP_PVTPLL_VOLT_SEL(800000000,  1, 12, 4),   /* 800 MHz */
     ROCKCHIP_PVTPLL_VOLT_SEL(700000000,  1, 32, 4),   /* 700 MHz */
     ```
   - Has self-calibration: measures actual frequency via `GCK_CNT_AVG` register, adjusts
     ring length until within 6.25% of target
   - Reads OTP (one-time-programmable fuses) to adjust ring lengths per chip
   - Adjusts voltage selection thresholds based on silicon binning (via `nvmem-cells`)

   **Critical finding: NO RK3568 support in `clk-pvtpll.c`!**
   The `of_device_id` table in `clk-pvtpll.c` only lists:
   - `rockchip,rv1103b-{core,enc,isp,npu}-pvtpll`
   - `rockchip,rv1126b-{core,enc,isp,npu,aisp}-pvtpll`
   - `rockchip,rk3506-core-pvtpll`

   There is **no `rockchip,rk3568-npu-pvtpll`** compatible string. The RK3568 uses the older
   PVTM measurement approach, not the newer PVTPLL-as-clock-source approach.

   **What PVTPLL would bring if it worked on RK3568:**

   | Benefit | Description |
   |---------|-------------|
   | **Per-chip voltage optimization** | Each ODROID-M1 board would get the minimum safe voltage for its specific silicon. "Fast" chips save 50-75 mV (≈5-10% power reduction). |
   | **Temperature-adaptive frequency** | As the chip heats up, PVTPLL frequency naturally drops → built-in thermal protection without needing a cooling governor. |
   | **No SCMI dependency** | PVTPLL is purely hardware — no firmware involvement, no SCMI bugs, no 1100→594 MHz gap problem. |
   | **True 700-1000 MHz without firmware** | Currently we need SCMI for >600 MHz. PVTPLL could provide these frequencies directly from the ring oscillator via the `npu_pvtpll_out` mux input. |
   | **Self-calibrating** | The newer driver measures actual output and auto-adjusts ring length. No manual frequency tables needed. |

   **Why we can NOT use it:**

   | Blocker | Detail |
   |---------|--------|
   | **No RK3568 PVTPLL driver** | `clk-pvtpll.c` has no RK3568 compatible. The RK3568's GRF_NPU PVTPLL registers differ from RV1103B/RV1126B. |
   | **No ring length tables** | Would need per-frequency ring_length/ring_sel values specifically characterized for RK3568 NPU silicon. Rockchip never published these. |
   | **Needs kernel integration** | PVTPLL is a platform driver that must be built into the kernel (or as a separate DKMS module). It must probe before the NPU driver. |
   | **Needs OTP calibration data** | The driver reads chip-specific fuse values (`nvmem-cells`) for calibration. RK3568 OTP layout is different. |
   | **PVTM hardware exists but is different** | RK3568 has a PVTM measurement block at 0xFDE90000 (7 rings for NPU), but the register layout differs from the newer PVTPLL config registers (GCK_CFG, GCK_LEN, GCK_CNT_AVG). |
   | **No DT bindings** | The Rockchip 6.6 kernel DTS for RK3568 has zero PVTPLL nodes — only PVTM measurement nodes exist in the BSP 5.10 DTS. |

   **Theoretical approach (high effort, high risk):**
   1. Port `clk-pvtpll.c` to RK3568: add compatible `rockchip,rk3568-npu-pvtpll`, determine
      GRF_NPU register offsets for ring oscillator config
   2. Characterize ring_length tables: for each target frequency (700-1000 MHz), find the
      ring_sel and ring_length that produce stable output across temperature range
   3. Add DT node at GRF_NPU base (0xFDC20000) with PVTPLL config registers
   4. Switch `clk_npu` mux to `npu_pvtpll_out` (CLKSEL_CON7 bit15=1)
   5. This would be a separate DKMS module (`rockchip-pvtpll-rk3568`) that must load before `rknpu`

   **Verdict: Not feasible for our project.** The characterization data doesn't exist, the
   register-level documentation is not public, and the risk of instability is very high. Our
   SCMI-based approach (CRU ≤600 MHz + SCMI 700-1000 MHz) achieves the same frequency range
   with proven stability. PVTPLL is a "nice to have" that Rockchip never enabled for RK3568.

### Answers

| Question | Answer |
|----------|--------|
| Can we get 1.2 GHz? | **No.** SCMI firmware caps at 1000 MHz safely. 1100+ MHz crashes or misreports. npll can't be retuned safely from a DKMS module. |
| Can we get exact 100 MHz? | **Yes**, via SCMI (min rate = 100 MHz). But CRU also gives 100 MHz (1200÷12). Already in OPP table as reachable. |
| Replace all 4 clocks with one? | **No.** The 3 CRU clocks (`clk`, `aclk`, `hclk`) are mandatory bus clocks — the NPU hardware requires separate core/AXI/APB domains. SCMI is a 4th clock that overrides the core frequency only. The architecture is: SCMI sets the core freq, CRU feeds the bus clocks. You cannot remove any. |
| Get rounder MHz numbers? | **Partially.** CRU values are inherently non-round (npll=1200 MHz with integer dividers). SCMI gives round values (700, 800, 900, 1000). The ~297 MHz OPP entry could be replaced with a 300 MHz SCMI entry, but SCMI has discrete steps that may not include 300. The "198 MHz" we see is SCMI's lowest useful rate. The non-round values are **cosmetic only** — they don't affect performance. |

### Possible improvement

- ✅ **Done** — CRU removed from OPP/devfreq, SCMI used for ALL frequencies (198–1000 MHz). The hybrid CRU/SCMI logic in `rknpu_devfreq_dkms.c` has been removed.

---

## Q2: Can we simplify the 8 GB RAM 3-layer fix to 2 or 1 layers?

> **✅ DONE — Reduced to 2 layers. CMA fully removed.**

### Final 2-layer setup

| # | Layer | What it does |
|---|-------|--------------|
| 1 | Kernel IOMMU `GFP_DMA32` patch | Forces IOMMU page table allocations below 4 GB. Compiled into Armbian 6.18.9 kernel. |
| 2 | Driver `dma_set_mask(32-bit)` + udev symlink `system → dma32` | Forces all buffer allocations below 4 GB via `dma32_heap` module. No CMA needed. |

**Removed:** CMA 3 GB reservation, custom DTB (`rk3568-odroid-m1-npu.dtb`), udev `linux,cma` rule.

---

## Q3: Do we really need CMA 3 GB? What does it give us?

> **✅ DONE — CMA fully removed. Using dma32_heap instead.**

`/dev/dma_heap/system` now symlinks to `/dev/dma_heap/dma32` (not `linux,cma`).
No custom DTB needed. Stock Armbian DTB works. Kernel default CMA (128 MB) remains
for other subsystems but NPU no longer depends on it.

---

## Q4: Are debugfs, procfs, devfreq, and voltage settings fully runtime-tunable?

### Debugfs (`/sys/kernel/debug/rknpu/`)

| Entry | Read | Write | Notes |
|-------|------|-------|-------|
| `freq_hz` | ✅ | ✅ | Set NPU frequency directly (bypasses devfreq governor) |
| `freq_mhz` | ✅ | ✅ | Same in MHz |
| `voltage_mv` | ✅ | ❌ | Read-only — voltage is set by OPP table, not directly writable |
| `voltage_uv` | ✅ | ❌ | Read-only |
| `opp_bypass` | ✅ | ✅ | 1 = bypass OPP voltage scaling, 0 = use OPP |
| `clock_source` | ✅ | ❌ | Shows available clocks and rates |
| `load` | ✅ | ❌ | Current NPU load percentage |
| `power` | ✅ | ✅ | Power on/off control |
| `reset` | ✅ | ✅ | Trigger soft reset |
| `delayms` | ✅ | ✅ | Power-off delay in ms |
| `mm` | ✅ | ❌ | Memory manager info |
| `version` | ✅ | ❌ | Driver version |
| `freq` | ✅ | ✅ | Legacy freq control |
| `volt` | ✅ | ❌ | Legacy voltage read |

### Procfs (`/proc/rknpu/`)

| Entry | Read | Write | Notes |
|-------|------|-------|-------|
| `freq` | ✅ | ✅ | Same as debugfs freq |
| `volt` | ✅ | ❌ | Voltage (read-only) |
| `load` | ✅ | ❌ | Load percentage |
| `power` | ✅ | ✅ | Power control |
| `reset` | ✅ | ✅ | Soft reset |
| `delayms` | ✅ | ✅ | Power-off delay |
| `mm` | ✅ | ❌ | Memory info |
| `version` | ✅ | ❌ | Version |

### Devfreq (`/sys/class/devfreq/fde40000.npu/`)

| Entry | Read | Write | Notes |
|-------|------|-------|-------|
| `governor` | ✅ | ✅ | Switch between: simple_ondemand, performance, powersave, userspace |
| `cur_freq` | ✅ | ❌ | Current frequency |
| `min_freq` | ✅ | ✅ | Minimum frequency bound |
| `max_freq` | ✅ | ✅ | Maximum frequency bound |
| `target_freq` | ✅ | ❌ | Governor's target |
| `polling_interval` | ✅ | ✅ | Governor polling interval in ms |

### Voltage

**Voltage is NOT freely writable at runtime.** It's coupled to the OPP table — when you set a frequency, the OPP table determines the voltage. You can set `opp_bypass=1` via debugfs to decouple voltage from OPP, then set frequency freely, but voltage stays at whatever it was. **There is no direct voltage write** — the regulator is controlled by the OPP framework.

### Summary

**Frequency: fully tunable at runtime** (via debugfs, procfs, or devfreq governor).
**Voltage: read-only** — controlled by OPP table, not directly writable.
**Governor: fully switchable** at runtime.
**Power, reset, delay: fully tunable** at runtime.

---

## Q5: Can we merge the custom DTB and the overlay into one?

> **✅ DONE — Already using stock DTB + single overlay. CMA removed.**

### Current boot config

```
user_overlays=rknpu
```

No `fdtfile` override needed. Stock Armbian DTB (`rk3568-odroid-m1.dtb`) works.
The `rknpu` overlay creates all NPU-related nodes (NPU, IOMMU, SRAM, PD6, OPP, clocks, thermal).
CMA dropped in favor of `dma32_heap`.

---

## Q6: Module parameters — cleanup for 1.0 release?

> **✅ DONE — 6 debug params removed. Only `dkms_force_contig_alloc` remains.**

Removed: `bypass_irq_handler`, `bypass_soft_reset`, `dkms_force_kernel_mapping`, `dkms_gem_addr_log`, `dkms_gem_addr_log_limit`, `dkms_alloc_use_fake_dev`.

Kept: `dkms_force_contig_alloc` (Y, always needed on RK3568). The debugfs/procfs interfaces provide sufficient runtime tuning.

---

## Q7: Do we still need the systemd devfreq service?

> **No — service removed. Root cause was a stale systemd service.**

The 600 MHz devfreq clamp was caused by `/etc/systemd/system/npu-performance.service` — a leftover service that wrote `echo 600000000` to BOTH `min_freq` AND `max_freq` at ~29s after boot. It was NOT a kernel quirk.

Investigation timeline:
- QoS starts at correct defaults (min=0, max=S32_MAX) at probe time (~15s)
- Stale service fires at ~29s, clamping both to 600000 kHz
- Traced via kprobe on `freq_qos_apply` — stack trace shows `min_freq_store` called from bash PID 1511

Fix: removed `npu-performance.service`. `install.sh` now cleans up stale services (`npu-performance`, `rknpu-devfreq`). No external service needed — the driver's OPP table and devfreq registration work correctly.

---

## Q8: Optimizations done, pending, and DRM vs misc performance

### Optimizations already implemented

| # | Optimization | Status | Impact |
|---|-------------|--------|--------|
| 1 | Log cleanup (dev_info→dev_dbg) | ✅ Done | 297→2 dmesg lines per inference |
| 2 | Regulator enable/disable in power_on/off | ✅ Done | Proper voltage scaling |
| 3 | SCMI clock wiring via overlay | ✅ Done | 600→1000 MHz (+67% freq headroom) |
| 4 | power_put_delay = 500ms | ✅ Done | Avoids re-powering NPU for rapid jobs |
| 5 | ktime-based load tracking | ✅ Done | Accurate devfreq governor decisions |
| 6 | SCMI gap detection (>50% drop = revert) | ✅ Done | Prevents silent 1100→594 MHz bug |
| 7 | OPP 1 GHz entry in overlay | ✅ Done | Full DVFS 200–1000 MHz |
| 8 | Direct alloc on /dev/rknpu | ✅ Done | No import-only limitation |
| 9 | Thermal dual-zone binding | ✅ Done | Throttling works from both sensors |
| 10 | All 4 devfreq governors | ✅ Done | performance, powersave, userspace, simple_ondemand |
| 11 | Full OPP range 200–1000 MHz | ✅ Done | Governors can use all frequencies |
| 12 | SRAM split configurable | ✅ Done | 0–100% NPU/video split |

### Optimizations still possible

| # | Optimization | Effort | Expected Impact | Priority |
|---|-------------|--------|-----------------|----------|
| A | ~~Remove debug module params~~ | Low | Cleaner interface | ✅ Done |
| B | ~~SCMI-only clock (drop CRU hybrid)~~ | Medium | Simpler driver, fewer bugs | ✅ Done |
| C | ~~Stock DTB + expanded overlay~~ | Medium | No custom DTB needed | ✅ Done |
| D | ~~Drop CMA, use dma32_heap~~ | Medium | No custom DTB, simpler setup | ✅ Done |
| E | ~~Fix devfreq clamp (remove systemd service)~~ | Medium | Cleaner boot | ✅ Done (root cause: stale npu-performance.service) |
| F | ~~DRM path optimization~~ | Medium | Equalize DRM/misc perf | ✅ Done (root cause: debug logging, not DRM overhead) |
| G | Buffer caching / pool allocator | High | Reduce alloc latency per inference | Low |
| H | Zero-copy DMA-BUF pipeline | High | Eliminate copies for camera→NPU | Low (app-specific) |

### DRM path performance — RESOLVED

> **✅ DRM and misc paths now perform identically: 43.8ms vs 43.6ms**

The "DRM path ~50% slower" claim was **wrong**. The real cause was debug logging spam:
- `dev_info` in `rknpu_power_on` fired on every `power_get` call (345 dmesg lines per inference)
- `LOG_ERROR` in `GEM_CREATE` and `MEM_SYNC` fired on every buffer operation
- `dev_info` in job submission fired on every submit

All demoted to `dev_dbg`. GEM ioctls no longer call `power_get`/`power_put` (they don't need NPU power).

| Path | Device | Latency (1000 MHz) |
|------|--------|--------------------|
| Misc | `/dev/rknpu` | 43.6 ms |
| DRM | `/dev/dri/renderD129` | 43.8 ms |

The RKNN library prefers `/dev/rknpu` when available, falls back to DRM. Both paths are equally fast.

---

## Summary: 1.0 Release Checklist

| # | Task | Priority | Status |
|---|------|----------|--------|
| 1 | Drop CMA 3GB, use dma32_heap + stock DTB | High | ✅ Done |
| 2 | Expand overlay to include NPU + IOMMU nodes | High | ✅ Done |
| 3 | Remove debug module parameters | Medium | ✅ Done (6 removed, 1 kept) |
| 4 | SCMI-only clocking (drop CRU hybrid) | Medium | ✅ Done |
| 5 | Devfreq range unlock | Low | ✅ Done (stale service removed, no service needed) |
| 6 | DRM path optimization | High | ✅ Done (DRM=misc, both 43.6ms) |
| 7 | Test and verify all changes on fresh Armbian | High | Pending |
