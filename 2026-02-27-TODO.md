# 2026-02-27 — Open Questions & Answers

Status: **Research only — nothing implemented yet.**

---

## Q1: Can we get 1.2 GHz, 100 MHz, replace all 4 clocks, or get rounder MHz numbers?

### RK3568 NPU Clock Architecture

The NPU has **two independent clock paths**:

1. **CRU path** (Clock & Reset Unit — hardware dividers):
   - `clk_npu_src` has two possible parents: **npll** (1200 MHz) and **gpll** (1200 MHz)
   - `clk_npu_src` is a COMPOSITE clock with a 4-bit integer divider (÷1…÷16)
   - From `clk_npu_src` → `clk_npu_pre_ndft` → `clk_npu` → branches to `aclk_npu_pre`, `hclk_npu_pre`, `pclk_npu_pre`
   - All 3 bus clocks (`aclk`, `hclk`, `pclk`) are derived from `clk_npu` via fixed dividers
   - **Max reachable via CRU**: 1200 MHz ÷ 2 = **600 MHz** (divider has no `CLK_SET_RATE_PARENT`, so it cannot retune npll)
   - CRU gives non-round values because 1200 MHz ÷ N: 1200, 600, 400, 300, 240, 200, ~171, 150, ~133, 120, ~109, 100, ~92, …

2. **SCMI path** (ARM System Control & Management Interface — firmware-controlled):
   - `clk_scmi_npu` — controlled by ARM Trusted Firmware via SCMI protocol
   - Supported rates: 198, 297, 396, 594, 600, 700, 800, 900, 1000 MHz
   - Above 1000 MHz: **1100 MHz silently maps to 594 MHz** (firmware gap), **1188 MHz crashes the board**
   - Safe max: **1000 MHz**

3. **PVTPLL** (Process-Voltage-Temperature PLL) — deep dive:

   **What it is:**
   PVTPLL is a ring-oscillator-based clock source built into the RK3568 silicon. Unlike a
   traditional PLL (which locks to a reference crystal), a PVTPLL generates a clock signal by
   routing a pulse through a chain of logic gates ("ring") — the output frequency is determined
   by the **ring length** (number of gates) and the **ring selector** (which ring topology to use).

   The key insight: the ring oscillator's frequency is **inherently sensitive to Process (silicon
   quality), Voltage, and Temperature**. A "fast" chip at low temperature oscillates faster than a
   "slow" chip at high temperature — for the exact same ring configuration. This is the feature,
   not a bug: PVTPLL automatically **adapts to the specific chip's silicon characteristics**.

   **Hardware in the RK3568:**
   The clock tree in `clk-rk3568.c` defines:
   ```
   PNAME(clk_npu_p) = { "clk_npu_pre_ndft", "npu_pvtpll_out" };
   MUX(CLK_NPU, "clk_npu", clk_npu_p, CLK_SET_RATE_PARENT, CLKSEL_CON(7), bit15, ...);
   GATE(CLK_NPU_PVTPLL, "clk_npu_pvtpll", "clk_npu_pre_ndft", CLK_IGNORE_UNUSED, ...);
   ```
   This means `clk_npu` is a 2:1 mux (bit 15 of CLKSEL_CON7):
   - **bit15=0**: `clk_npu_pre_ndft` → CRU path (current, max 600 MHz)
   - **bit15=1**: `npu_pvtpll_out` → PVTPLL ring oscillator output

   The hardware registers live at **GRF_NPU base 0xFDC2_0000**. The PVTM measurement unit
   (different from PVTPLL!) lives at **0xFDE9_0000** with 7 ring selectors.

   **Live clock tree confirms the mux exists but PVTPLL is unused:**
   ```
   clk_npu_pre_ndft     0  1  0  200000000   (current parent of clk_npu)
      clk_npu_pvtpll     0  0  0  200000000   (gate exists, enable_count=0)
      clk_npu            0  3  0  200000000   (mux output → npu@fde40000)
   ```

   **How Rockchip BSP 5.10 used PVTM (predecessor system):**
   The Hardkernel BSP kernel (5.10) uses a **PVTM** (Process Voltage Temperature Monitor) system,
   not the newer PVTPLL driver. This is a two-step process:

   1. **PVTM measurement** (`rockchip_pvtm.c`): At boot, the kernel measures the chip's
      ring oscillator frequency at a known voltage/temperature/clock:
      ```dts
      /* From rk3568.dtsi (Hardkernel BSP) */
      npu-opp-table {
          rockchip,pvtm-voltage-sel = <
              0        84000   0    /* PVTM < 84000 → voltage level 0 */
              84001    87000   1    /* PVTM 84001-87000 → level 1 */
              87001    91000   2    /* PVTM 87001-91000 → level 2 */
              91001    100000  3    /* PVTM > 91001 → level 3 */
          >;
          rockchip,pvtm-freq = <408000>;      /* measure at 408 MHz */
          rockchip,pvtm-volt = <900000>;      /* measure at 900 mV */
          rockchip,pvtm-ch = <0 5>;           /* NPU PVTM channel 0, sub-channel 5 */
          rockchip,pvtm-sample-time = <1000>; /* 1000 µs sample window */
          rockchip,pvtm-number = <10>;        /* average 10 measurements */
          rockchip,pvtm-ref-temp = <40>;      /* reference temperature 40°C */
          rockchip,pvtm-temp-prop = <26 26>;  /* temperature compensation */
      };
      ```

   2. **Voltage selection** (`rockchip_opp_select.c`): Based on the PVTM measurement, each
      OPP entry selects the appropriate voltage column:
      ```dts
      opp-800000000 {
          opp-microvolt = <925000 925000 1000000>;     /* default */
          opp-microvolt-L0 = <925000 925000 1000000>;  /* slow silicon */
          opp-microvolt-L1 = <900000 900000 1000000>;  /* medium */
          opp-microvolt-L2 = <875000 875000 1000000>;  /* fast silicon */
          opp-microvolt-L3 = <875000 875000 1000000>;  /* fastest */
      };
      ```
      A "fast" chip (high PVTM count) gets lower voltage → **less power, less heat**.
      A "slow" chip (low PVTM count) gets higher voltage → **guaranteed stability**.

   **The newer PVTPLL driver (`clk-pvtpll.c` in Rockchip 6.6 kernel):**
   This is an evolution of the PVTM system used on **newer SoCs** (RV1103B, RV1126B, RK3506).
   It goes one step further: instead of just measuring and selecting voltage, it uses the ring
   oscillator **directly as the clock source**. The driver:
   - Registers as a `clk_hw` clock provider (output name: "pvtpll")
   - Has a frequency→ring_length lookup table per SoC:
     ```c
     /* From rv1103b_npu_pvtpll_table[] */
     ROCKCHIP_PVTPLL_VOLT_SEL(1000000000, 1, 12, 7),  /* 1 GHz, ring_sel=1, length=12 */
     ROCKCHIP_PVTPLL_VOLT_SEL(900000000,  1, 12, 6),   /* 900 MHz */
     ROCKCHIP_PVTPLL_VOLT_SEL(800000000,  1, 12, 4),   /* 800 MHz */
     ROCKCHIP_PVTPLL_VOLT_SEL(700000000,  1, 32, 4),   /* 700 MHz */
     ```
   - Has self-calibration: measures actual frequency via `GCK_CNT_AVG` register, adjusts
     ring length until within 6.25% of target
   - Reads OTP (one-time-programmable fuses) to adjust ring lengths per chip
   - Adjusts voltage selection thresholds based on silicon binning (via `nvmem-cells`)

   **Critical finding: NO RK3568 support in `clk-pvtpll.c`!**
   The `of_device_id` table in `clk-pvtpll.c` only lists:
   - `rockchip,rv1103b-{core,enc,isp,npu}-pvtpll`
   - `rockchip,rv1126b-{core,enc,isp,npu,aisp}-pvtpll`
   - `rockchip,rk3506-core-pvtpll`

   There is **no `rockchip,rk3568-npu-pvtpll`** compatible string. The RK3568 uses the older
   PVTM measurement approach, not the newer PVTPLL-as-clock-source approach.

   **What PVTPLL would bring if it worked on RK3568:**

   | Benefit | Description |
   |---------|-------------|
   | **Per-chip voltage optimization** | Each ODROID-M1 board would get the minimum safe voltage for its specific silicon. "Fast" chips save 50-75 mV (≈5-10% power reduction). |
   | **Temperature-adaptive frequency** | As the chip heats up, PVTPLL frequency naturally drops → built-in thermal protection without needing a cooling governor. |
   | **No SCMI dependency** | PVTPLL is purely hardware — no firmware involvement, no SCMI bugs, no 1100→594 MHz gap problem. |
   | **True 700-1000 MHz without firmware** | Currently we need SCMI for >600 MHz. PVTPLL could provide these frequencies directly from the ring oscillator via the `npu_pvtpll_out` mux input. |
   | **Self-calibrating** | The newer driver measures actual output and auto-adjusts ring length. No manual frequency tables needed. |

   **Why we can NOT use it:**

   | Blocker | Detail |
   |---------|--------|
   | **No RK3568 PVTPLL driver** | `clk-pvtpll.c` has no RK3568 compatible. The RK3568's GRF_NPU PVTPLL registers differ from RV1103B/RV1126B. |
   | **No ring length tables** | Would need per-frequency ring_length/ring_sel values specifically characterized for RK3568 NPU silicon. Rockchip never published these. |
   | **Needs kernel integration** | PVTPLL is a platform driver that must be built into the kernel (or as a separate DKMS module). It must probe before the NPU driver. |
   | **Needs OTP calibration data** | The driver reads chip-specific fuse values (`nvmem-cells`) for calibration. RK3568 OTP layout is different. |
   | **PVTM hardware exists but is different** | RK3568 has a PVTM measurement block at 0xFDE90000 (7 rings for NPU), but the register layout differs from the newer PVTPLL config registers (GCK_CFG, GCK_LEN, GCK_CNT_AVG). |
   | **No DT bindings** | The Rockchip 6.6 kernel DTS for RK3568 has zero PVTPLL nodes — only PVTM measurement nodes exist in the BSP 5.10 DTS. |

   **Theoretical approach (high effort, high risk):**
   1. Port `clk-pvtpll.c` to RK3568: add compatible `rockchip,rk3568-npu-pvtpll`, determine
      GRF_NPU register offsets for ring oscillator config
   2. Characterize ring_length tables: for each target frequency (700-1000 MHz), find the
      ring_sel and ring_length that produce stable output across temperature range
   3. Add DT node at GRF_NPU base (0xFDC20000) with PVTPLL config registers
   4. Switch `clk_npu` mux to `npu_pvtpll_out` (CLKSEL_CON7 bit15=1)
   5. This would be a separate DKMS module (`rockchip-pvtpll-rk3568`) that must load before `rknpu`

   **Verdict: Not feasible for our project.** The characterization data doesn't exist, the
   register-level documentation is not public, and the risk of instability is very high. Our
   SCMI-based approach (CRU ≤600 MHz + SCMI 700-1000 MHz) achieves the same frequency range
   with proven stability. PVTPLL is a "nice to have" that Rockchip never enabled for RK3568.

### Answers

| Question | Answer |
|----------|--------|
| Can we get 1.2 GHz? | **No.** SCMI firmware caps at 1000 MHz safely. 1100+ MHz crashes or misreports. npll can't be retuned safely from a DKMS module. |
| Can we get exact 100 MHz? | **Yes**, via SCMI (min rate = 100 MHz). But CRU also gives 100 MHz (1200÷12). Already in OPP table as reachable. |
| Replace all 4 clocks with one? | **No.** The 3 CRU clocks (`clk`, `aclk`, `hclk`) are mandatory bus clocks — the NPU hardware requires separate core/AXI/APB domains. SCMI is a 4th clock that overrides the core frequency only. The architecture is: SCMI sets the core freq, CRU feeds the bus clocks. You cannot remove any. |
| Get rounder MHz numbers? | **Partially.** CRU values are inherently non-round (npll=1200 MHz with integer dividers). SCMI gives round values (700, 800, 900, 1000). The ~297 MHz OPP entry could be replaced with a 300 MHz SCMI entry, but SCMI has discrete steps that may not include 300. The "198 MHz" we see is SCMI's lowest useful rate. The non-round values are **cosmetic only** — they don't affect performance. |

### Possible improvement

- **Remove CRU from the OPP table entirely** and use SCMI for ALL frequencies. SCMI supports: 198, 297, 396, 594, 600, 700, 800, 900, 1000 MHz. This would simplify the hybrid CRU/SCMI logic in `rknpu_devfreq_dkms.c` (remove the threshold switching). Downside: if SCMI firmware is buggy/unavailable, NPU would have no clock at all.

---

## Q2: Can we simplify the 8 GB RAM 3-layer fix to 2 or 1 layers?

> **✅ DONE — Reduced to 2 layers. CMA fully removed.**

### Final 2-layer setup (implemented 2026-02-27)

| # | Layer | What it does |
|---|-------|--------------|
| 1 | Kernel IOMMU `GFP_DMA32` patch | Forces IOMMU page table allocations below 4 GB. Compiled into Armbian 6.18.9 kernel. |
| 2 | Driver `dma_set_mask(32-bit)` + udev symlink `system → dma32` | Forces all buffer allocations below 4 GB via `dma32_heap` module. No CMA needed. |

**Removed:** CMA 3 GB reservation, custom DTB (`rk3568-odroid-m1-npu.dtb`), udev `linux,cma` rule.

---

## Q3: Do we really need CMA 3 GB? What does it give us?

> **✅ DONE — CMA fully removed. Using dma32_heap instead (Option B implemented).**

`/dev/dma_heap/system` now symlinks to `/dev/dma_heap/dma32` (not `linux,cma`).
No custom DTB needed. Stock Armbian DTB works. Kernel default CMA (128 MB) remains
for other subsystems but NPU no longer depends on it.

---

## Q4: Are debugfs, procfs, devfreq, and voltage settings fully runtime-tunable?

### Debugfs (`/sys/kernel/debug/rknpu/`)

| Entry | Read | Write | Notes |
|-------|------|-------|-------|
| `freq_hz` | ✅ | ✅ | Set NPU frequency directly (bypasses devfreq governor) |
| `freq_mhz` | ✅ | ✅ | Same in MHz |
| `voltage_mv` | ✅ | ❌ | Read-only — voltage is set by OPP table, not directly writable |
| `voltage_uv` | ✅ | ❌ | Read-only |
| `opp_bypass` | ✅ | ✅ | 1 = bypass OPP voltage scaling, 0 = use OPP |
| `clock_source` | ✅ | ❌ | Shows available clocks and rates |
| `load` | ✅ | ❌ | Current NPU load percentage |
| `power` | ✅ | ✅ | Power on/off control |
| `reset` | ✅ | ✅ | Trigger soft reset |
| `delayms` | ✅ | ✅ | Power-off delay in ms |
| `mm` | ✅ | ❌ | Memory manager info |
| `version` | ✅ | ❌ | Driver version |
| `freq` | ✅ | ✅ | Legacy freq control |
| `volt` | ✅ | ❌ | Legacy voltage read |

### Procfs (`/proc/rknpu/`)

| Entry | Read | Write | Notes |
|-------|------|-------|-------|
| `freq` | ✅ | ✅ | Same as debugfs freq |
| `volt` | ✅ | ❌ | Voltage (read-only) |
| `load` | ✅ | ❌ | Load percentage |
| `power` | ✅ | ✅ | Power control |
| `reset` | ✅ | ✅ | Soft reset |
| `delayms` | ✅ | ✅ | Power-off delay |
| `mm` | ✅ | ❌ | Memory info |
| `version` | ✅ | ❌ | Version |

### Devfreq (`/sys/class/devfreq/fde40000.npu/`)

| Entry | Read | Write | Notes |
|-------|------|-------|-------|
| `governor` | ✅ | ✅ | Switch between: simple_ondemand, performance, powersave, userspace |
| `cur_freq` | ✅ | ❌ | Current frequency |
| `min_freq` | ✅ | ✅ | Minimum frequency bound |
| `max_freq` | ✅ | ✅ | Maximum frequency bound |
| `target_freq` | ✅ | ❌ | Governor's target |
| `polling_interval` | ✅ | ✅ | Governor polling interval in ms |

### Voltage

**Voltage is NOT freely writable at runtime.** It's coupled to the OPP table — when you set a frequency, the OPP table determines the voltage. You can set `opp_bypass=1` via debugfs to decouple voltage from OPP, then set frequency freely, but voltage stays at whatever it was. **There is no direct voltage write** — the regulator is controlled by the OPP framework.

### Summary

**Frequency: fully tunable at runtime** (via debugfs, procfs, or devfreq governor).
**Voltage: read-only** — controlled by OPP table, not directly writable.
**Governor: fully switchable** at runtime.
**Power, reset, delay: fully tunable** at runtime.

---

## Q5: Can we merge the custom DTB and the overlay into one?

> **✅ DONE — Already using stock DTB + single overlay. CMA removed.**

### Current boot config (implemented 2026-02-27)

```
user_overlays=rknpu
```

No `fdtfile` override needed. Stock Armbian DTB (`rk3568-odroid-m1.dtb`) works.
The `rknpu` overlay creates all NPU-related nodes (NPU, IOMMU, SRAM, PD6, OPP, clocks, thermal).
CMA dropped in favor of `dma32_heap`.

---

## Q6: Module parameters — cleanup for 1.0 release?

### Current module parameters

| Parameter | Default | Purpose | Keep for 1.0? |
|-----------|---------|---------|---------------|
| `bypass_irq_handler` | 0 | Skip IRQ processing | ❌ **Remove** — debug only, dangerous in production |
| `bypass_soft_reset` | 0 | Skip error recovery | ❌ **Remove** — debug only, hides errors |
| `dkms_force_contig_alloc` | Y | Force contiguous allocations | ✅ **Keep but hardcode** — always needed on RK3568, no reason to disable |
| `dkms_force_kernel_mapping` | N | Force kernel vmap of GEM | ❌ **Remove** — debug only, wastes vmalloc space |
| `dkms_gem_addr_log` | N | Log GEM addresses | ❌ **Remove** — debug spam |
| `dkms_gem_addr_log_limit` | 64 | Max log entries | ❌ **Remove** (depends on above) |
| `dkms_alloc_use_fake_dev` | N | Bypass IOMMU for alloc | ❌ **Remove** — test only, breaks IOMMU |

### Recommendation

For a clean 1.0 release, **remove all 7 module parameters**:
- Hardcode `force_contig_alloc = true` (always needed)
- Remove the 6 debug parameters entirely
- The debugfs/procfs interfaces provide sufficient runtime tuning

This eliminates `/sys/module/rknpu/parameters/` clutter and prevents users from accidentally breaking things.

---

## Q7: Do we still need the systemd devfreq service?

### Current situation

The `rknpu-devfreq.service` is a **workaround** for a kernel devfreq core bug/quirk:
- The devfreq OPP notifier fires ~20 seconds after boot and resets `min_freq`/`max_freq` to 600 MHz
- The systemd service retries at +10s and +20s to override this
- Without the service, governors are clamped to 600 MHz

### Can we fix this properly?

| Approach | Effort | Risk |
|----------|--------|------|
| Keep systemd service (current) | ✅ Done | Low — ugly but works |
| Fix in driver: register OPP notifier to re-set bounds | Medium | Need to understand exact notifier race |
| Fix in driver: use `dev_pm_qos_add_request` at probe | Medium | Tried already — QoS gets overridden |
| Fix by using SCMI-only (no CRU OPPs) | Medium | Eliminates the hybrid OPP that confuses devfreq (YES, YES, DO THIS!!!) |
| Upstream kernel fix | High | Correct solution but takes months |

### Recommendation

**Keep the service for now.** It's 5 lines, works reliably, and has no performance impact. For a 1.0 release, it's acceptable. The proper fix is to investigate the OPP notifier chain and either:
- Register a late-stage notifier in the driver that re-asserts the bounds, or
- Simplify the OPP table to avoid whatever triggers the re-clamping

---

## Q8: Optimizations done, pending, and DRM vs misc performance

### Optimizations already implemented

| # | Optimization | Status | Impact |
|---|-------------|--------|--------|
| 1 | Log cleanup (dev_info→dev_dbg) | ✅ Done | 297→2 dmesg lines per inference |
| 2 | Regulator enable/disable in power_on/off | ✅ Done | Proper voltage scaling |
| 3 | SCMI clock wiring via overlay | ✅ Done | 600→1000 MHz (+67% freq headroom) |
| 4 | power_put_delay = 500ms | ✅ Done | Avoids re-powering NPU for rapid jobs |
| 5 | ktime-based load tracking | ✅ Done | Accurate devfreq governor decisions |
| 6 | SCMI gap detection (>50% drop = revert) | ✅ Done | Prevents silent 1100→594 MHz bug |
| 7 | OPP 1 GHz entry in overlay | ✅ Done | Full DVFS 200–1000 MHz |
| 8 | Direct alloc on /dev/rknpu | ✅ Done | No import-only limitation |
| 9 | Thermal dual-zone binding | ✅ Done | Throttling works from both sensors |
| 10 | All 4 devfreq governors | ✅ Done | performance, powersave, userspace, simple_ondemand |
| 11 | Full OPP range 200–1000 MHz | ✅ Done | Governors can use all frequencies |
| 12 | SRAM split configurable | ✅ Done | 0–100% NPU/video split |

### Optimizations still possible

| # | Optimization | Effort | Expected Impact | Priority |
|---|-------------|--------|-----------------|----------|
| A | Remove debug module params | Low | Cleaner interface | Medium |
| B | SCMI-only clock (drop CRU hybrid) | Medium | Simpler driver, fewer bugs | Medium |
| C | Stock DTB + expanded overlay | Medium | No custom DTB needed | High |
| D | Drop CMA, use dma32_heap | Medium | No custom DTB, simpler setup | High |
| E | Fix devfreq clamp in driver (remove systemd service) | Medium | Cleaner boot | Low |
| F | Buffer caching / pool allocator | High | Reduce alloc latency per inference | Medium |
| G | Zero-copy DMA-BUF pipeline | High | Eliminate copies for camera→NPU | Low (app-specific) |

### DRM path ~50% slower than misc — what can we do?

**Root cause analysis:**

The DRM path (`/dev/dri/renderD129`) is slower because:

1. **Allocation overhead**: `dma_alloc_attrs()` with fallback logic + GEM object bookkeeping vs simple `dma_alloc_coherent()`
2. **IOMMU mapping per object**: Each GEM buffer gets an IOMMU mapping (TLB invalidation, page table updates)
3. **DRM subsystem overhead**: GEM handle management, DRM ioctl dispatch, refcounting
4. **Buffer lifecycle**: DRM GEM objects have complex refcounting (flink, handle tracking, mmap support)

**What can we do to equalize?**

| Approach | Effect | Feasibility |
|----------|--------|-------------|
| **Use /dev/rknpu exclusively** | Best perf right now | ✅ Already works — tell users to use it |
| Pre-allocate a buffer pool in DRM | Amortize alloc cost | Medium — need to cache GEM objects |
| Use `dma_alloc_coherent` in GEM path too | Remove `dma_alloc_attrs` overhead | Low effort but breaks non-contiguous fallback |
| Persistent IOMMU mappings | Avoid per-buffer map/unmap | Medium — need IOMMU domain pinning |
| **Remove DRM path entirely** | Simplify driver, single path | Aggressive — breaks DRM buffer sharing |

**Recommendation**: For 1.0, document that `/dev/rknpu` is the **recommended path** for best performance. Keep DRM for compatibility but don't optimize it. The RKNN library already uses the misc device path by default when available.

---

## Summary: 1.0 Release Checklist

| # | Task | Priority | Effort | Status |
|---|------|----------|--------|--------|
| 1 | ~~Drop CMA 3GB, use dma32_heap + stock DTB~~ | High | Medium | ✅ DONE 2026-02-27 |
| 2 | ~~Expand overlay to include NPU + IOMMU nodes~~ | High | Medium | ✅ Already done |
| 3 | Remove 7 debug module parameters | Medium | Low | Pending |
| 4 | Simplify to SCMI-only clocking (optional) | Medium | Medium | Pending |
| 5 | Fix devfreq clamp in driver | Low | Medium | Pending |
| 6 | Document /dev/rknpu as recommended path | Medium | Low | Pending |
| 7 | Test and verify all changes on fresh Armbian | High | Low | Pending |
